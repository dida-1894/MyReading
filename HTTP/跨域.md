# 跨域

## cookie
- cookie是浏览器提供的功能，存储在浏览器中，浏览器的安装目录里会有一个cookie文件夹，存放`各个域名`下的cookie
- 网页在发送http请求
	1. 发送请求之前，检查是否有该网站相应的cookie
	2. 有则自动添加到request header中的cookie字段里（每一次的http请求，浏览器都会自动完成这两个步骤）
	3. 因为以上的两个步骤，cookie里存放的应该是每次都需要发送给服务器端的数据（如身份认证信息）。
	4. 每个域名下的cookie大小最大为4KB，数量最多为20个
### cookie格式
#### document.cookie
JS原生API提供获取cookie的方法： document.cookie

## 同源策略
- A网页设置的cookie， B网页不能打开，除非这两个网页“同源”
	- 协议相同
	- 域名相同
	- 端口相同
- 非同源限制范围
	- Cookie、LocalStorage、IndexDB无法读取
	- DOM无法获取
	- Ajax请求不能发送
### Cookie
- cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享
- 两个二级页面的一级域名相同，但二级域名不相同，浏览器允许通过设置document.domain共享cookie
`http://a1.example.com/a.html` 和 `http://b1.example.com/b.html`设置相同的`document.domain`例如
``` document.domain = 'example.com'```
在A页面上设置`document.cookie = 'test=hello'`
B页面上就可以读取`var allCookie = document.cookie`

- 服务器设置Cookie时，指定Cookie的所属域名为一级域名`Set-Cookie: key=value; domain=.example.com; path= / ` 这样二级域名和三级域名都可以读取这个Cookie

- 只适用于Cookie和iframe窗口， LocalStorage和IndexDB无法通过此种方法来规避同源

### iframe
- 因为两个页面不同源而无法获取对方的DOM，会导致iframe和window.open方法打开的窗口无法与父窗口通信
- 规避方法
	- 片段识别符
		- 本身指URL后面的#，如http://example.com/x.html#fragment 的#fragment。如果只改变片段标识符，页面不会重新刷新
		- 父窗口把信息写入子窗口的片段标识符
	``` var src = originURL + '#' + data; document.getElementById('myIframe').src = src ```
	子窗口通过监听`hashchange`事件得到通知
			```
			 window.onhashchange = checkMessage;
			 function checkMessage() {
					 var message = window.location.hash;
					 ....
			 }
	 ```
	 子窗口也可以改变父窗口的片段标识符
	 `parent.location.href = target + '#' + hash;`
	- window.name
		- 浏览器的window.name属性，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取它
		- 
