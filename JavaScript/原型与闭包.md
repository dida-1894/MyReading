- 一切的引用类型都是对象，对象是属性的集合
- 对象都是通过构造函数来创建的，但函数依旧是对象，是属性的集合
### prototype原型
- 每一个对象都有一个prototype对象属性，prototype包含所有实例共享的属性和方法。
- 使用原型对象的好处就是让所有的对象实例共享它所包含的属性和方法。
- 所有的prototype对象都有一个constructor属性，指向对象本身。
### __proto__隐式原型
- 每一个对象都有一个隐藏属性，`__proto__ ` 这个属性对脚本来说完全不可见。
- `__proto__`用来连接实例与构造函数的原型对象，而不是实例与构造函数本身 `person1.__proto__ == Person.prototype`
- prototype也是对象也一个普通的被Object()创建出来的对象，有自己的 `__proto__`,指向Object.prototype
- 在访问一个对象的属性时 `alert(f1.a)` 会现在f1的prototype中寻找，再沿着 `f1.__proto__`找到Foo.prototype中这就是原型链了
- 所有对象的原型链都会找到Object.prototype,`Object.prototype.__proto__ === null` 原型链的终点
- 前面说一切的应用类型都是对象，对象由Object()函数创建，`Object.__proto__ === Function.prototype` `Function.__proto__ === Function.prototype`
- 区分一个对象的属性究竟是基本属性还是从原型链上找到的 - hasOwnProperty，那些从原型链上找到的属性和方法就是继承。
### instanceof
```js
function Foo() {
    //...
}
let f1 = new Foo()
console.log(f1 instanceof Foo) //true
console.log(f1 instanceof Object) //true
```
- instanceof用来判断引用类型， 根据上面的例子，instanceof沿着f1的 `__proto__`同时沿着Foo的prototype来找，如果两条路线能找到同一个引用，即为同一个对象，返回true。否则返回false
- instanceof表示的就是一种继承关系，或者原型链结构
### 执行上下文

- 在js语句执行之前要做的工作
    - 变量声明，默认值为undefined
    - this的赋值
    - 函数声明赋值
- 以上三种数据的准备情况就是‘执行上文||执行上下文环境’
- js的执行上下文有三种情况 全局代码，函数体，eval  
- 函数每被调用一次，都会产生一个新的执行上下文环境，函数在*定义*的时候，就已经确定了函数体内部的*自由变量*和*作用域*
```js
var a = 10
function fn() {
    console.log(a)
}
function bar(f) {
    var a = 20
    f()
}
bar(fn)
```
